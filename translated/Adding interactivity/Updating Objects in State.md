# 객체 state 업데이트하기

state에는 어떤 javcascript 값도 담을 수 있습니다. 하지만 리액트에서는 state를 직접 바꿀수는 없어야하죠. 대신에 객체를 업데이트 하고 싶다면, 새로운 객체를 만들고 그 것을 이용해서 state를 설정해야합니다.(이미 존재하는 객체의 복사본을 만들던지 말이죠)

### 목차
- 리액트에서 객체형태의 state를 업데이트하는 방법
- 변경하지 않고(불변성을 지키면서) 중첩 객체를 업데이트하기
- 불변성이란, 그리고 불변성을 깨지 않는 방법  
- Immer 를 이용해 반복적인 작업을 줄여 객체 복사하기

## Mutation 이란?

state엔 javascript의 어떤 값도 저장할 수 있습니다.우린 지금까지 number, string, boolean 값과 함께 해왔습니다. 이런 javascript 값들은 “변경할 수 없습니다”. 다시 말해 바꿀 수 없거나 읽기 전용임을 의미합니다. 값을 대체함으로써 다시 렌더링을 트리거할 수 있습니다. 

State 는 0에서 5로 바뀔 수 있습니다. 하지만 숫자 0 그 자체는 바뀌지 않습니다. 자바스크립트의 number, string, boolean과 같이 내장 원시형 값들은 변경을 하는 것이 불가능합니다.

이제 객체 state를 봅시다.

정확히는 객체 그자체의 내부 컨텐츠를 바꾸는 것은 가능합니다. 이것을 mutation이라고 부릅니다. 

하지만 객체형태의 리액트 state들은 기술적으로 변경은 가능하지만, 그것들을 변경할 수 없는 number, boolean, string 처럼 다루어야 합니다. 그것들을 변경하는 대신 항상 대체해야합니다.

### state를 읽기 전용으로 다루자

다시 말해서 state로 넣는 어떤 자바스크립트 객체라도 읽기전용으로 다루어야합니다. 이 예제는현재 포인터 위치를 나타내는 객체 형태의 state를 다룹니다. 빨간색 점은 미리보기 영역에서 마우스 커서를 터치하고 움직일 떄 움직일 것 입니다. 하지만 그 점은 제자리에 있네요:

문제는 이 작은 코드입니다.

이 코드는 이전 렌더링의 position으로 할당된 객체를 변경합니다. 함수를 사용하여 state를 사용하지 않으면 리액트는 그 객체를 변경할 방법이 없습니다. 그래서 리액트는 그에대한 응답으로 아무것도 하지 않습니다. 이것은 마치 우리가 음식을 이미 먹은 뒤 순서를 바꾸려고 하는것과 똑같습니다. 어떤 경우엔 state 변경이 될지도 모르지만 추천하지는 않습니다. 우리는 렌더링 중에 우리가 접근하려는 state값을 읽기 전용으로 취급해야합니다. 

이런 경우에 다시 렌더링을 트리거하기 위해선 새로운 오브젝트를 만들어 state 설정 함수에 그것을 전달해야합니다.

setPosition은 React에게 다음과 같이 지시합니다.
- 새로운 객체로 position을 대체합니다.
- 그리고 이 컴포넌트를 다시 렌더링합니다.  

이제 미리보기 영역을 터치하거나 마우스로 가리킬 때 빨간 점이 마우스 포인터를 따라다니는 것에 주목해보세요.

### 심화 학습
Local mutation도 괜찮습니다. 
이 코드는 문제가 있습니다. 이유는 state에 존재하는 객체를 바꾸었기 떄문입니다.

하지만 이 코드는 괜찮네요.왜냐하면 우리가 생성한 새로운 객체를 변경했기 때문이죠.

사실상 이 코드와 정확히 같습니다. 

**
Mutation은 state에 이미 존재하는 객체들을 변경하려 할 떄만 문제가 일어납니다. 새로 생성한 객체를 변경시키는 것은 괜찮습니다. 어떤 코드도 그 객체를 참조하고 있지 않기 떄문입니다.그것을 변경해도 그것에 의존하고있는 어떤것에도 영향을 미치지 않을 것 입니다. 이것을 “local mutation”이라고 합니다. 심지어 렌더링하는 동안에도 local mutatation을 할 수 있습니다. 매우 편리하고 아주 좋습니다.

## Spread 구문을 이용한 객체 복사
이전 예시에서 position객체는 현재 커서의 위치에 따라 매번 새로 생성된다. 하지만 가끔은 새로 생성하는 새로운 객체의 부분으로써 기존데이터를 포함하고 싶을 것 입니다. 예를들어 폼 안에서 다른 필드 값들을 유지하면서 하나의 필드만 업데이트 하고 싶을 수도 있습니다. 

이 입력값 필드들은 onChange 핸들러들이 state를 변경하기 때문에 작동하지 않습니다

예를 들, 이 줄은 과거 렌더링의 상태를 변경합니다. 

우리가 기대하는 동작을 실행시키기 위한 좋은 방법은 새로운 객체를 생성하고 setPerson을 넘기는 것입니다. 하지만 여기서는 필드 중에 하나만 변경되었기 때문에 기존 데이터를 복사하려고 합니다.

모든 프로퍼티를 분리하여 복사할 필요없이 … 객체 spread 구문을 쓸 수 있습니다. 

이제 폼이 작동하네요!

각각의 인풋 필드에 state 변수를 분리하여 선언하지 않은것에 주목하세요. 좀더 폼의 스케일이 커지면, 올바르게 업데이트를 하는 한 객체로 묶어 모든 데이터를 관리하는 것은 정말 편리합니다.

… spread 구문은 오직 1레벨의 깊이까지만 “얕게” 복사한다는 것에 주의하세요. 이것은 빠르게 만들수 있습니다. 하지만 만약 중첩 프로퍼티를 업데이트 하고싶다면 한번더 사용해야한다는 것을 의미합니다.

### 심화 학습
객체를 정의함에 있어서 대괄호를 사용하여 동적으로 이름 속성을 지정할 수 있습니다 .
3개의 다른 이벤트 핸들러를 쓰는 대신 하나만 쓰는 예시가 있습니다.

## 중첩 객체 업데이트
이런 중첩된 객체 구조가 있다고 해보겠습니다.

person.artwork.city를 업데이트 하고 싶다면 변경 방법은 명확합니다.

하지만 리액트에서는 state를 변경할 수 없는 것으로 취급합니다. city를 바꾸기 위해서는 첫 번째로 새로운 artwork 객체를 생성해야 합니다(이전 데이터로 미리 채워짐). 그리고 새로운 artwork를 가리키는 새로운 person 객체를 만들어야합니다:

혹은 하나의 함수를 호출하여 쓸 수도 있습니다:

이것은 단어를 많이 써야하지만 대부분의 경우에 잘 작동합니다:

### 심화학습
객체들은 실제로 중첩되지 않습니다.

이러한 객체는 코드 상에서 “중첩” 된 것으로 표현됩니다.

하지만 “중첩”은 객체들이 어떻게 동작하는지 생각해보는데 부정확한 방법입니다. 코드가 실행될 때 ”중첩된” 객체라는것은 없습니다. 실제로는 2개의 다른 형태의 객체들을 볼 수 있습니다.

obj1은 obj2 “안에” 있지 않습니다. 예를들어 obj3은 obj1을 가리키고 있습니다.

Obj3.arwork.city를 변경한다면  obj2.artwork.city와 obj1.city 둘 모두에 영향을 미칩니다. 그 이유는 obj3.artwork, obj2.artwork, obj1이 같은 객체이기 때문입니다. 객체들이 “중첩”되었다고 생각한다면 이러한 것을 확인하기 어렵습니다. 그 객체들은 속성으로 서르를 “가리키는” 별도의 객체 입니다.

## immer를 이용한 간결한 업데이트 로직 작성하기
만약 state가 깊게 중첩되었다면 “flat”을 고려해보세요. 하지만 state 구조를 변경시키고 싶지 않다면, 중첩 spread에 대한 손쉬운 방법을 선호할 수도 있습니다. Immer는 편리하게 구문을 변화시키고 본사본을 생성하는 인기있는 라이브러리입니다. immer를 사용하면 우리가 쓴 코드가 규칙을 깨는 것 처럼 보이지만 객체를 변경시켜줍니다.    

일반적인 변경 방식과는 다르게 이전 state를 덮어쓰지 않습니다.

### 심화 학습
immer는 어떻게 작동하나요?
immer가 제공한 draft는 Proxy라고 부르는 객체의 특별한 타입입니다. 이를 사용하여 수행한 작업을 “기록”합니다. 이것이 우리가 자유롭게 원하는대로 변경할 수 있는 이유입니다. 내부적으로 immer가 draft의 어떤 부분이 변경되었는지 이해하고 편집 내용이 포함된 완전히 새로운 객체를 생성합니다.

Immer를 생성하기 위해서는:
1. npm install use-immer 을 실행하여 dependency로써 immer를 추가합니다.
2. import { useState } from 'react’를 import { useImmer } from 'use-immer’로 대체합니다
아래에 immer로 변환하는 예시가 있습니다.

### 심화학습
왜 리액 트에서는 state를 변경하는 것이 추천되지 않을까요.

여기엔 몇가지 이유가 있습니다.
- 디버깅
- 최적화
- 새로운 특성
- 요구의 변화
- 단순한 실행(너무 길어 당장은 스킵하고 넘어갑니다)

### 복습
- 리액트의 모든 state는 변경할 수 없는 값으로 취급해라
- 객체 형태의 state를 저장하면 객체를 변경해도 렌더링이 트리거되지 않고 이전 렌더링의 스냅샷인 state를 변경한다.
- 객체를 변경하는 대신에, 새로운 객체를 만들어라. 그리고 state를 설정함으로써 다시 렌더링을 트리거해라.
- 객체의 복사본을 만들기위해 {...obj, something: 'newValue’} 같은 객체 spread 구문을 쓸 수있다.
- Spread 구문은 얕게 복사한다: 오직 1레벨만 복사한다.
- 중첩 객체를 복사하려면 업데이트하는 업데이트하는 위치에서 끝까지 복사본을 만들어야 한다
- 중복된 코드를 줄이기위해 immer를 사용해라

setState => 변수 업데이트 트리거 => 렌더링(이때 비로소 state를 바꾼다)  