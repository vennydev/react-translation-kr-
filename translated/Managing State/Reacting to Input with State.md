# state로 인풋에 반응하기

리액트는 UI를 조작하기위해 선언적인 방법을 씁니다. 개별적인 UI조각들을 직접 다루는 것 대신, 컴포넌트가 가질 수 있는 다양한 상태들을 묘사합니다. 그리고 유저 인풋에 응답하여 그 state들을 전환시킵니다. 디자이너가 UI에 대해 생각하는 방식과 비슷하지요.

### 이번 장에서 배울 것,
- 선언적 UI프로그래밍과 명령형 UI 프로그래밍의 차이점 
- 컴포넌트가 가질 수 있는 다양한 시각적 상태를 열거하는 방법
- 코드에서 다양한 시각적 상태들 간에 변화를 일으키는 법 

## 선언적 UI와 명령형 UI 비교
UI 상호작용을 디자인할 때, 아마도 유저의 행동에 따라 UI가 어떤식을 변경되야하는지 생각할 것 입니다. 유저가 답을 제출하는 폼이 있다고 가정해봅시다.

- 폼에 무언가를 입력할 때, “제출”버튼이 *활성화됩니다*.
- “제출”버튼을 누르면 폼과 버튼이 *비활성화됩니다*. 그리고 스피너가 *나타나죠*.
- 만약 네트워크 요청이 성공하면, 폼이 *숨겨집니다*. 그 뒤 “Thank you” 메시지가 *나타납니다*.
- 만약 네트워크 요청이 실패한다면, 에러 메시지가 *나타납니다*. 그리고 폼이 다시 *활성화됩니다*.

명령형 프로그래밍에선, 위의 내용은 상호작용을 구현하는 방법과 직접적으로(directly) 일치합니다. 무엇이 일어날지에 따라 UI를 어떻게 변경할지에 대한 정확한 지침을 작성해야합니다. 다르게 생각해볼 수 있는 방법도 있습니다: 누군가의 차에 탔습니다. 그리고 그에게 어디로 갈지 차례대로 얘기하는 걸 상상해보세요.

(Img)

그는 당신이 어디로 가고 싶은지 모릅니다. 그냥 명령을 따르는 것 뿐이죠.(방향을 잘 못 알려준다면, 결국 잘못된 장소에 도착할 것 입니다.) 이것을 명령적이라고 이야기합니다. 왜냐하면  각 요소를 “명령”해야 하기 때문입니다. 스피너에서 버튼까지 모든 요소를 다요. 컴퓨터에게 UI를 어떻게 업데이트해야하는지 말하면서 말입니다.

다음 명령형 UI프로그래밍의 예제에는, 리액트를 _사용하지 않은_ 폼이 있습니다. 오직 브라우저 DOM만을 사용합니다.  

<https://codesandbox.io/s/wh03mi?file=%2Findex.js&utm_medium=sandpack>

위 예제에서 명령적으로 UI를 조작하는 것은 충분히 잘 작동합니다. 그런데 더 복잡한 시스템 안에서는 관리하기가 기하급수적으로  더 어려워집니다. 만약 이렇게 엄청 달라진 폼들로 가득찬 페이지를 업데이트해야한다고 생각해보세요. 새로운 UI요소나 새로운 상호작용을 추가하는 작업은 기존의 모든 코드에 없던 버그가 생기진 않았는지 주의 깊게 확인해야 할 것입니다.(예를들면 무언가를 보이거거나 숨기게끔 하는걸 까먹는 일 같은거요)

리액트는 이 문제를 해결하게끔 만들어졌습니다.

리액트에서는 UI를 직접 조작할 필요가 없습니다. 이 말은 컴포넌트들을 직접 활성화, 비활성화하거나, 보이게 또는 안 보이게끔 할 수 없다는 말입니다. 대신 **무엇을 보여주길 원하는지 알려주어야 합니다.** 그럼 리액트는 UI를 업데이트 하는 방법을 알아냅니다. 이번엔 택시를 탔다고 생각해봅시다. 그럼 그들에게 정확히 어디서 돌아야하는지 말할 필요는 없고 그냥 어디로 가고싶은지 말합니다. 그곳으로 데려가는게 그들의 일입니다. 또한 그들은 우리가 생각치 못햇던 지름길을 알지도 모릅니다.

(Img)

## UI를 선언적으로 생각하기
위에서 어떻게 폼을 선언적으로 만드는지 보았습니다. 리액트에서 어떻게 사고해야할지 더 잘 이해하기 위해서는, 아래와 같이 UI를 다시 만들어보아야 합니다.
 
1. 컴포넌트의 다른 시각적 상태들을 인식하세요.
2. 그 상태 변경을 유발할 요소를 정하세요.
3. useState를 이용하여 메모리에 state를 나타내세요.
4. 불필요한 state 변수들을 지우세요.
5. state를 설정하기위해 이벤트 핸들러를 연결하세요.

### 1단계: 컴포넌트의 다른 시각적 상태 인식

컴퓨터 과학에서 여러 상태 중 하나에 속한 “상태 기계”에 대해서 들었을 겁니다. 디자이너와 일한다면 다양한 “시각적 상태”들을 위한 목업들을 본적이 있을 겁니다. 리액트는 디자인과 컴퓨터 과학 모두에 걸쳐있습니다(교차로에 서있습니다). 그래서 두 아이디어에서 모두 영감을 받았습니다.

우선 사용자가 볼 수있는 UI의 다양한 “상태들”을 모두 시각화 해야합니다”

- **비어있음**: “제출” 버튼이 비활성화 됩니다.
- **입력중**: “제출”버튼이 활성화됩니다. 
- **제출중**: 폼이 완전히 비활성화 되고, 스피너가 보여집니다.  
- **성공 시**: 폼 대신 “Thank you” 메시지가 보여집니다.
- **실패 시**: 제출 중일 때의 상태와 같습니다. 하지만 에러메시지가 추가됩니다.

디자이너처럼, 로직을 추가하기 전에 다양한 상태에 대한 “mock”을 만들고 싶을 수도 있습니다. 예를들어 폼의 시각적 부분만을 위한 mock이 있습니다. 이 mock은 디폴트 값이 ‘empty’인 `status` prop에 의해 제어됩니다. 

<https://codesandbox.io/s/ewr4uj?file=%2FApp.js&utm_medium=sandpack>

저 Prop을 원하는대로 불러도 좋습니다. 이름 짓는게 중요한건 아니니까요. 성공 메시지를 보려면 `status = ‘empty’`를 `status = ‘success’`로 수정해봅시다. Mock을 사용하면 논리를 연결하기 전에 UI를 빠르게 반복할 수 있습니다. 여기 같은 컴포넌트의 프로토타입을 좀더 구체화 해봤습니다. 여전히 `status` prop에 의해 제어됩니다.

<https://codesandbox.io/s/pmnojw?file=%2FApp.js&utm_medium=sandpack>

#### 📒심화학습
**한번에 많은 시각적 상태들을 보여주기**
만약 컴포넌트가 많은 시각적 상태들을 가지고 있다면, 한 페이지에 모두 보여주는게 편할겁니다. 

<https://codesandbox.io/s/f0p7sj?file=%2FApp.js&utm_medium=sandpack> 

이런 페이지를 “living styleguides” 또는 “storybooks”이라고 부릅니다. 
### 2단계: state 변화가 트리거할 것을 정하기

두 가지 종류의 입력에 반응하여 state 업데이트를 트리거할 수 있습니다.

- **사람 쪽의 입력**: 버튼 클릭, 필드에 값 입력, 링크 탐색 같은 것 입니다.
- **컴퓨터 쪽의 입력**: 네트워크 응답 도착, 시간 초과 완료, 이미지 로드와 같은 것 입니다

(Human Inputs img) / (Computer inputs img)

두 가지 경우 모두, UI를 업데이트하기 위해 **state 변수들을 설정해야만 합니다.** 우리가 개발중인 폼의 경우 몇 가지 다른 입력에 대한 응답으로 상태를 변경해야합니다:

- 텍스트 인풋을 변경하는 것(사람 쪽 입력)은 _빈_ 상태에서 타이핑 상태로(혹은 그 반대로도) 전환되어야 합니다. 이는 텍스트 박스가 비어 있는지 여부에 따라 다릅니다.
- 제출 버튼(사람 쪽 입력)을 클릭하면 _제출 중_ 상태로 전환됩니다.
- 성공 네트워크 응답(컴퓨터 쪽 입력)은 _성공_ 상태로 전환됩니다.
- 실패 네트워크 응답(컴퓨터 쪽 입력)은 알맞은 에러 메시지와 함께 _에러_ 상태로 전환됩니다. 

####  주의
> 사람 쪽 입력에는 종종 이벤트 핸들러가 필요합니다.

이 흐름을 시각화해보려면, 종이에 라벨이 붙은 원으로 각각의 상태와 두 상태 간 변화를 화살표를 이용해 그려보세요.  이 방법으로 많은 흐름들을 그릴 수 있고, 구현하기 한참 전에 버그를 골라낼 수 있습니다.
 
(Flow Img)

### 3단계: `useState`를 이용하여 메모리에 상태를 나타내기
이번엔 `useState`를 이용하여 컴포넌트의 시각적 상태를 메모리에 나타내야합니다. 단순한게 핵심입니다: 각 state 조각은 “움직이는 조각” 입니다. 그리고 **가능한 한 적은 수의 “움직이는 조각들”을 원합니다.** 복잡해질 수 록 더 많은 버그가 생깁니다!

_절대적으로 있어야야만_ 하는 state와 함께 시작해봅시다. 예를들어 마지막의 에러를 저장하기 위해서  인풋에 대한 `answer`와  `error`(있다면)를 저장해야합니다:

```javascript
const [answer, setAnswer] = useState('');
const [error, setError] = useState(null);
```

이제 보여주려는 시각적 상태들 중 하나를 나타내는 state변수가 필요합니다. 일반적으론 메모리에 그것을 나타내는 한 가지 이상의 방법이 있습니다. 그러니 그 방법을 실험해봐야할 필요가 있지요.

바로 최고의 방법을 생각해내는게 힘들다면, 가능한 모든 시각적 상태가 포함되도록 충분한 상태를 추가하는 것부터 시작해보세요.

```javascript
const [isEmpty, setIsEmpty] = useState(true);
const [isTyping, setIsTyping] = useState(false);
const [isSubmitting, setIsSubmitting] = useState(false);
const [isSuccess, setIsSuccess] = useState(false);
const [isError, setIsError] = useState(false);
```

처음 아이디어는 최고의 방법은 아닐지도 모릅니다. 그래도 괜찮습니다. state를 리팩토링하는 것은 과정 중의 일부이니까요!

### 4단계: 필요없는 state 변수들을 지우기
state의 중복을 방지해서 필수적인 항목만 가져가려 합니다. 리팩토링에 약간의 시간을 쏟는것이 컴포넌트를 이해하기 쉽고 중복을 줄이며 의도치 않은 의미를 피할 수 있게 해줍니다. 우리의 목적은  **메모리의 상태가 사용자에게 보여주려는 유효한 UI를 보여주지 않는** 그러한 경우들을 방지하는 것 입니다.(예를들어 에러메시지를 띄우면서 동시에 인풋을 비활성화시키면 사용자는 에러를 수정할 수 없습니다. 이런 경우를 원하지는 않겠지요.)

여기 state 변수들에 관해 궁금해할 만한 것들이 있습니다:
- **이 상태가 역설을 일으키나요?** 예를들어 `isTyping`과 `isSubmitting` state는 동시에 `true`여서는 안됩니다. 여기서 역설은 보통 state에 적절한 제약이 걸리지 않았음을 의미합니다. 두 개의 boolean으로 가능한 네 가지 조합이 있지만 오직 세 가지만 유효한 상태에 해당합니다. “불가능한” state를 제거하기 위해서, 다음 세 가지 중 하나의 값을 갖는 `status`에 묶을 수 있습니다: 'typing', 'submitting', 'success'. 
- **다른 state에 이미 이용할 수 있는 같은 정보가 들어있진 않나요?** 다음은 또 다른 역설입니다: `isEmpty` 와 `isTyping`은 동시에 `true`가 될 수 없습니다. 저 state들을 분리하면 동기화되지 않고 버그가 발생할 위험이 있습니다. 다행히도 `isEmpty`를 지우고 대신에 `answer.length === 0`을 확인할 수 있습니다. 
- **다른 state 변수의 역에서 같은 정보를 얻을 수 있나요?** `isError`은 필요하지 않습니다. `error !== null`를 대신 확인할 수 있기 때문입니다.

이렇게 정리 후에 _필수적인_ 3개의 변수만이 남습니다. 7개에서 줄였네요:

``` const [answer, setAnswer] = useState('');
const [error, setError] = useState(null);
const [status, setStatus] = useState('typing'); // 'typing', 'submitting', or 'success'
``` 

이젠 그것들이 필요한걸 압니다. 기능을 망가뜨리지 않고는 그것들 중 어느것도 삭제할 수 없기 때문입니다.

#### 📒심화학습
**리듀서로 “불가능한” 상태 제거** 
폼에 필요한 state를 나타내기에 3개의 변수로 충분했습니다. 그러나 완전히 이해가 되지 않는 중간 상태들이 있습니다. `status`가 `’success’`일 때 `error`가 null이 아니라는 것은 잘 이해가 가지않네요. 상태를 보다 정확히 모델링하려면(짜려면), [상태를 리듀서로 빼내야합니다.](https://react.dev/learn/extracting-state-logic-into-a-reducer) 리듀서는 여러 state 변수들을 하나의 객체에 묶어주고 연관된 로직을 통합해줍니다.

### 5단계: state를 설정하기위해 이벤트를 연결하기

마지막으로 상태를 업데이트하기 위한 이벤트핸들러를 만듭니다. 아래는 모든 이벤트 핸들러가 있는 최종 폼의 모습입니다.

<https://react.dev/learn/reacting-to-input-with-state>

비록 이 코드가 처음에 명령형으로 작성했던 코드보다 길긴하지만, 더 안정적입니다. 모든 상호작용을 상태의 변경으로 표현하면 나중에 기존의 것을 망가뜨리지않고 새로운 시각적 상태를 도입할 수 있습니다. 또한 상호작용 그 자체의 로직을 변경할 필요없이 각각의 상태에서 보여야할 것들을 변경할 수 있게 해줍니다.  

### 복습
- 선언형 프로그래밍이란 UI를 하나하나 관리(명령형)할 필요없이 각 시각적 상태만을 관리해서 UI를 그리는 것을 말합니다.
- 컴포넌트를 만들 때:
    1. 시각적 상태들을 인식한다.
    2. 상태 변경에 따라 사람과 컴퓨터가 트리거할 것을 결정한다.
    3. useState로 state를 모델링한다(useState는 state를 주시하다가 필요할 때 변경시킨다. 이 의미를 모델링이라 표현한듯 싶다.)
    4. 필요없는 state를 없앤다. 이는 발생할 버그와 역설들을 없애준다.
    5. state를 설정하기 위해 이벤트 핸들러를 연결한다.