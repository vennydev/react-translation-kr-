# 렌더와 커밋
---
화면에 컴포넌트들이 보이기 전에, 그것들은 리액트에 의해 렌더링 되어야 합니다. 이 과정에서 이 단계들을 이해하는 것은 우리가 짠 코드들이 어떻게 실행되고 어떻게 동작하는지 생각해보는데 도움을 줄 것 입니다. 

### 이번 챕터에서 배우는 것
- 리액트에서 렌더링이란
- 리액트가 언제, 왜 컴포넌트를 렌더링 시킬까 
- 화면에 컴포넌트를 보여주는 단계
- 왜 렌더링이 매번 DOM 업데이트를 하진 않을까

당신의 컴포넌트들이 재료들을 이용해 맛있는 음식을 만들면서 주방에서 요리를 하고있다고 생각해보세요. 리액트는 손님들로부터(주문에 대한) 요청을 접수하고 그들의 주문을 주방으로 가지고 오는 웨이터입니다. UI를 요청하고 보여주는 과정은 3가지 단계를 거칩니다.
1. 렌더링을 트리거시킵니다(손님의 주문을 주방으로 전달합니다)
2. 컴포넌트를 렌더링합니다(주방에서 해당 음식을 준비합니다) 
3. DOM을 커밋합니다.(테이블에 음식을 가져다 놓습니다)

## 1단계: 렌더링을 트리거합니다.
컴포넌트가 렌더링하는 두 가지 이유가 있습니다.
1. 컴포넌트의 **최초 rendering**일 때.
2. 컴포넌트(혹은 조상 컴포넌트 중의 하나)의 **state가 업데이트** 되었을 때. 

#### 초기 렌더링
우리가 만든 앱이 실행될 때, 최초 render가 일어나야 합니다. 프레임 워크나 샌드박스는 때때로 이 코드를 숨깁니다. 하지만 타겟팅된 DOM node와 함께 createRoot가 호출되었습니다. 그러고나면 우리가 만든 컴포넌트를 가지고 render 메소드가 호출됩니다.

root.render() 를 지워보고 컴포넌트가 사라지는걸 확인해보세요.

#### state가 업데이트 될때 다시 렌더링됩니다
컴포넌트가 최초에 한번 렌더링이 되면, set function을 이용하여 state를 업데이트 시킴으로써 다시 렌더링을 트리거시킬 수 있습니다. 컴포넌트의 state를 업데이트 시키면 자동으로 렌더링이 대기열에 추가되게 합니다.(첫 주문 이후 지금 목이 마른지 배가 고픈지(상태)에 따라 차, 디저트 등의 주문을 하는 레스토랑의 손님을 상상해봅시다)

## 2단계: 리액트가 컴포넌트들을 렌더링합니다.
렌더링이 트리거되고 나면 React는 화면에 무엇이 보여야 할지 알아내기 위해(계산하기 위해) 컴포넌트들을 호출합니다. **"렌더링"은 컴포넌트를 호출하는 React입니다.(이 과정이 렌더링이다 라고 이해하면 될듯하다)
- 최초 렌더링에 React는 root 컴포넌트를 호출합니다.
- 그 다음 렌더링의 경우엔 React는 state를 업데이트하여 렌더링을 트리거시킨 함수 컴포넌트를 호출합니다.

이 과정은 재귀적입니다: 만약 업데이트된 컴포넌트가 다른 컴포넌트를 반환한다면, React는 그 컴포넌트를 다음에 렌더링할 것입니다. 그 컴포넌트가 무언가를 반환해도 역시 마찬가지이고 그 다음도 계속 그럴 것 입니다. 이 과정은 더이상 중첩된 컴포넌트가 없을 때까지 계속됩니다. React는 화면에 무엇이 보여야할지 정확히 알고 있습니다.
다음의 예제에서 리액트는 Gallery()와 Image()를 몇 차례 호출 할 것 입니다.

- 초기 렌더링 중에 React는 <section>, <h1> 그리고 3개의 <img> 태그와 같은 DOM node들을 생성할 것입니다.
- 다시 렌더링되는 중에 React는 이전 렌더링 이후에 변경된 속성이 있는 경우 이를 계산합니다. 위의 정보로는 다음 단계인 커밋 단계까지 아무 작업도 하지 않습니다.  

### 함정
렌더링은 항상 순수하게 계산이 되어야 합니다.
- **동일한 입력값과 동일한 출력값.** 동일한 입력값이 주어지면 컴포넌트는 항상 같은 JSX를 반환해야만 합니다.(누군가 토마토가 들어간 샐러드를 주문했는데, 양파가 들어간 샐러드를 받아선 안되는 것처럼요)
- **자신의 일만 신경써야한다.** 렌더링 전에 존재했던 어떤 객체나 변수도 바꿔서는 안됩니다.(어떤 손님이 다른 누군가의 주문을 바꿔서는 안됩니다)

### 깊이알기
**성능 최적화**
만약 업데이트된 컴포넌트가 트리 구조상 최상단에 위치해있다면, 그 안에 중첩된 모든 컴포넌트를 렌더링하는 기본동작의 성능은 좋지 않습니다. 만약 성능 이슈가 발생했다면, 성능 섹션에 설명된 몇가지 선택적인 해결 방법이 있습니다. 미리 최적화하지 마세요!

## 3단계: React는 변경 사항을 DOM에 커밋합니다.
컴포넌트를 렌더링(호출)한 뒤, React는 DOM을 수정합니다.
- 초기 렌더링의 경우 React는 appendChild() DOM API을 사용하여 생성한 DOM node들을 화면에 표시합니다.
- 다시 렌더링이 일어나는 경우 React는 최신 렌더링 결과물을 DOM과 매칭시키기 위하여 필요한 최소한의 작업들(렌더링 중에 계산되어진)을 적용시킵니다.

React는 렌더링 결과 간에 다른점이 있을 때만 DOM node들을 변경합니다. 이번 예시엔 매초마다 부모 컴포넌트로부터 다른 props를 전달받아 다시 렌더링되는 컴포넌트가 있습니다. 다시 렌더링이 될때 텍스트는 사라지지 않지만 어떻게 <input> 안에 텍스트를 입력할 수 있고, value를 업데이트 할 수 있는지 주목해보세요.  

그 이유는 마지막 단계에서 React가 새로운 time이 들어있는 <h1>의 컨텐츠만을 업데이트하기 때문입니다. 좀전과 같은 위치의 JSX에서 <input>이 있는 것을 볼 수 있는데 기 이유는 바로 React가 <input>을 건드리지 않았기 때문입니다. 혹은 그 value를요. 

### 에필로그: Browser paint 
렌더링이 끝나고 React가 DOM을 업데이트하고나면 브라우저는 스크린을 다시 그릴 것 입니다. 이 단계는 "브라우저 렌더링"이라고 알려져있지만, 문서 전반에 걸쳐 혼선을 피하기위해 우리는 이를 "painting"이라고 부를 것 입니다.

## 복습
- 리액트 앱에서 화면 업데이트 시 3가지 단계가 일어난다.
    1. Trigger
    2. Render
    3. Commit
- 컴포넌트에서 실수를 찾기위해 Strict Mode(엄격 모드)를 사용할 수 있다.
- React는 최근 렌더링된 결과와 같으면 DOM을 건드리지 않는다.

<!-- trigger가 "유발시킨다"로 의역하면 딱딱하게 들려서 걍 트리거라고 썼다 -->
<!-- commit: 변경을 기록하는 이력-->